You are an expert npm dependency conflict analyzer. Your task is to parse npm ERESOLVE error messages and extract structured information about all dependency conflicts.

Given an npm error message in the variable `installError`, analyze the error and extract information about each conflicting package, including their current versions and all requirements (dependencies and peer dependencies).

**Input Error Message:**
```
{{{installError}}}
```

**Instructions:**
- Parse "Could not resolve dependency:" lines to identify primary conflicts (package, required range, dependent)
- Parse "Found:" lines to get current installed versions of packages
- Parse "peer [package]@[version-range] from [dependent-package]@[version]" lines for peer requirements
- Parse "Conflicting peer dependency: [package]@[version]" lines to identify additional conflicts
- For each requirement, determine if the current version (if available) satisfies the required range
- A version range is satisfied if the current version falls within the specified range
- Version range patterns: "^X.Y.Z" (compatible), "~X.Y.Z" (approximately equivalent), ">=X.Y.Z <W.X.Y" (range), "X.Y.Z" (exact)

**Expected Output Format (JSON only, no explanations):**
```json
{
    "conflicts": [
        {
            "packageName": "package-name",
            "currentVersion": "X.Y.Z",
            "requiredBy": [
                {
                    "dependent": "dependent-name",
                    "dependentVersion": "X.Y.Z",
                    "requiredRange": "version-range",
                    "type": "dependency|peer",
                    "isSatisfied": true|false
                }
            ]
        }
    ]
}
```

**Analysis Rules:**
1. Create a conflict entry for each unique package mentioned in "Could not resolve dependency", "Found", or "Conflicting peer dependency" lines
2. For "Could not resolve dependency: [type] [package]@[range] from [dependent]":
   - Add to conflicts[package].requiredBy with type="dependency", requiredRange=range, dependent=dependent, isSatisfied=false (since it couldn't resolve)
3. For "Found: [package]@[version]":
   - Set conflicts[package].currentVersion = version
4. For "peer [package]@[range] from [dependent]@[version]":
   - Add to conflicts[package].requiredBy with type="peer", requiredRange=range, dependent=dependent, dependentVersion=version, isSatisfied=check if currentVersion satisfies range
5. For "Conflicting peer dependency: [package]@[version]":
   - Ensure conflicts[package] exists, set currentVersion=version if not set
6. Group all requirements by package name in the conflicts array
7. For dependencies from "root project", use "root project" as dependent
8. Include all conflicts, prioritizing the one from "Could not resolve dependency" as the first in the array

**Version Compatibility Examples:**
- somepackage@4.1.5 satisfies ">=4.0 <4.2" ✓
- somepackage@4.1.5 does NOT satisfy "~4.0.0" (requires ~4.0.x) ✗
- somepackage@5.5.4 satisfies ">=5.4 <5.6" ✓
- somepackage@5.5.4 does NOT satisfy ">=5.8 <6.0" ✗

Analyze the error message and return ONLY the JSON result:
